{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\nvar FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nvar FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nvar TokenManager =\n/** @class */\nfunction () {\n  function TokenManager() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n\n\n  TokenManager.prototype.openDatabase_ = function () {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise(function (resolve, reject) {\n      var request = indexedDB.open(TokenManager.DB_NAME, FCM_TOKEN_DETAILS_DB_VERSION);\n\n      request.onerror = function (event) {\n        reject(event.target.error);\n      };\n\n      request.onsuccess = function (event) {\n        resolve(event.target.result);\n      };\n\n      request.onupgradeneeded = function (event) {\n        var db = event.target.result;\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        }); // Make sure the sender ID can be searched\n\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n    return this.openDbPromise_;\n  };\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n\n\n  TokenManager.prototype.closeDatabase = function () {\n    var _this = this;\n\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(function (db) {\n        db.close();\n        _this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  };\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n\n\n  TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var index = objectStore.index('fcmToken');\n        var request = index.get(fcmToken);\n\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        request.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n\n  TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var scopeRequest = objectStore.get(swScope);\n\n        scopeRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        scopeRequest.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n\n  TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var senderIdTokens = [];\n        var cursorRequest = objectStore.openCursor();\n\n        cursorRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        cursorRequest.onsuccess = function (event) {\n          var cursor = event.target.result;\n\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  };\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n\n\n  TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {\n    var _this = this;\n\n    var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n    var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" + (\"endpoint=\" + subscription.endpoint + \"&\") + (\"encryption_key=\" + p256dh + \"&\") + (\"encryption_auth=\" + auth);\n\n    if (pushSet) {\n      fcmSubscribeBody += \"&pushSet=\" + pushSet;\n    }\n\n    var headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n    var subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions).then(function (response) {\n      return response.json();\n    }).then(function (response) {\n      var fcmTokenResponse = response;\n\n      if (fcmTokenResponse['error']) {\n        var message = fcmTokenResponse['error']['message'];\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n          message: message\n        });\n      }\n\n      if (!fcmTokenResponse['token']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n      }\n\n      if (!fcmTokenResponse['pushSet']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n      }\n\n      return {\n        token: fcmTokenResponse['token'],\n        pushSet: fcmTokenResponse['pushSet']\n      };\n    });\n  };\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n\n\n  TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return subscription.endpoint === masterTokenDetails['endpoint'] && arrayBufferToBase64(subscription['getKey']('auth')) === masterTokenDetails['auth'] && arrayBufferToBase64(subscription['getKey']('p256dh')) === masterTokenDetails['p256dh'];\n  };\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n\n\n  TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {\n    var details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var request = objectStore.put(details);\n\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        request.onsuccess = function (event) {\n          resolve();\n        };\n      });\n    });\n  };\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n\n\n  TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {\n    var _this = this;\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId).then(function (allTokenDetails) {\n      if (allTokenDetails.length === 0) {\n        return;\n      }\n\n      var index = allTokenDetails.findIndex(function (tokenDetails) {\n        return swRegistration.scope === tokenDetails['swScope'] && senderId === tokenDetails['fcmSenderId'];\n      });\n\n      if (index === -1) {\n        return;\n      }\n\n      return allTokenDetails[index];\n    }).then(function (tokenDetails) {\n      if (!tokenDetails) {\n        return;\n      }\n\n      return swRegistration.pushManager.getSubscription().catch(function (err) {\n        throw _this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n      }).then(function (subscription) {\n        if (subscription && _this.isSameSubscription_(subscription, tokenDetails)) {\n          return tokenDetails['fcmToken'];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new FCM token.\n   */\n\n\n  TokenManager.prototype.createToken = function (senderId, swRegistration) {\n    var _this = this;\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    } // Check for existing subscription first\n\n\n    var subscription;\n    var fcmTokenDetails;\n    return swRegistration.pushManager.getSubscription().then(function (subscription) {\n      if (subscription) {\n        return subscription;\n      }\n\n      return swRegistration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n    }).then(function (sub) {\n      subscription = sub;\n      return _this.subscribeToFCM(senderId, subscription);\n    }).then(function (tokenDetails) {\n      fcmTokenDetails = tokenDetails;\n      return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n    }).then(function () {\n      return fcmTokenDetails['token'];\n    });\n  };\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n\n\n  TokenManager.prototype.deleteToken = function (token) {\n    var _this = this;\n\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n    }\n\n    return this.getTokenDetailsFromToken(token).then(function (details) {\n      if (!details) {\n        throw _this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return _this.openDatabase_().then(function (db) {\n        return new Promise(function (resolve, reject) {\n          var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n          var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          var request = objectStore.delete(details['swScope']);\n\n          request.onerror = function (event) {\n            reject(event.target.error);\n          };\n\n          request.onsuccess = function (event) {\n            if (event.target.result === 0) {\n              reject(_this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  };\n\n  return TokenManager;\n}();\n\nexport default TokenManager;","map":{"version":3,"sources":["../src/models/token-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nconst FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nconst FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nexport default class TokenManager {\n  private errorFactory_: ErrorFactory<string>;\n  private openDbPromise_: Promise<IDBDatabase>;\n\n  static DB_NAME: 'fcm_token_details_db';\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  openDatabase_() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise((resolve, reject) => {\n      const request = indexedDB.open(\n        TokenManager.DB_NAME,\n        FCM_TOKEN_DETAILS_DB_VERSION\n      );\n      request.onerror = event => {\n        reject((<IDBRequest>event.target).error);\n      };\n      request.onsuccess = event => {\n        resolve((<IDBRequest>event.target).result);\n      };\n      request.onupgradeneeded = event => {\n        var db = (<IDBRequest>event.target).result;\n\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n\n    return this.openDbPromise_;\n  }\n\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  closeDatabase() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(db => {\n        db.close();\n        this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  getTokenDetailsFromToken(fcmToken) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const index = objectStore.index('fcmToken');\n        const request = index.get(fcmToken);\n        request.onerror = function(event) {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = function(event) {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getTokenDetailsFromSWScope_(swScope) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        scopeRequest.onsuccess = event => {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getAllTokenDetailsForSenderId_(senderId): Promise<Array<Object>> {\n    return this.openDatabase_().then(db => {\n      return new Promise<Array<Object>>((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n\n        const senderIdTokens = [];\n\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        cursorRequest.onsuccess = event => {\n          const cursor = (<IDBRequest>event.target).result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  subscribeToFCM(senderId, subscription, pushSet?): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody =\n      `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (pushSet) {\n      fcmSubscribeBody += `&pushSet=${pushSet}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(\n      FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions\n    )\n      .then(response => response.json())\n      .then(response => {\n        const fcmTokenResponse = response;\n        if (fcmTokenResponse['error']) {\n          const message = fcmTokenResponse['error']['message'];\n          throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n            message: message\n          });\n        }\n\n        if (!fcmTokenResponse['token']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN\n          );\n        }\n\n        if (!fcmTokenResponse['pushSet']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET\n          );\n        }\n\n        return {\n          token: fcmTokenResponse['token'],\n          pushSet: fcmTokenResponse['pushSet']\n        };\n      });\n  }\n\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  isSameSubscription_(subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (\n      subscription.endpoint === masterTokenDetails['endpoint'] &&\n      arrayBufferToBase64(subscription['getKey']('auth')) ===\n        masterTokenDetails['auth'] &&\n      arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n        masterTokenDetails['p256dh']\n    );\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  saveTokenDetails_(\n    senderId,\n    swRegistration,\n    subscription,\n    fcmToken,\n    fcmPushSet\n  ) {\n    const details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const request = objectStore.put(details);\n        request.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = event => {\n          resolve();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  getSavedToken(senderId, swRegistration) {\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId)\n      .then(allTokenDetails => {\n        if (allTokenDetails.length === 0) {\n          return;\n        }\n\n        const index = allTokenDetails.findIndex(tokenDetails => {\n          return (\n            swRegistration.scope === tokenDetails['swScope'] &&\n            senderId === tokenDetails['fcmSenderId']\n          );\n        });\n\n        if (index === -1) {\n          return;\n        }\n\n        return allTokenDetails[index];\n      })\n      .then(tokenDetails => {\n        if (!tokenDetails) {\n          return;\n        }\n\n        return swRegistration.pushManager\n          .getSubscription()\n          .catch(err => {\n            throw this.errorFactory_.create(\n              Errors.codes.GET_SUBSCRIPTION_FAILED\n            );\n          })\n          .then(subscription => {\n            if (\n              subscription &&\n              this.isSameSubscription_(subscription, tokenDetails)\n            ) {\n              return tokenDetails['fcmToken'];\n            }\n          });\n      });\n  }\n\n  /**\n   * Creates a new FCM token.\n   */\n  createToken(senderId, swRegistration): Promise<String> {\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    // Check for existing subscription first\n    let subscription;\n    let fcmTokenDetails;\n    return swRegistration.pushManager\n      .getSubscription()\n      .then(subscription => {\n        if (subscription) {\n          return subscription;\n        }\n\n        return swRegistration.pushManager.subscribe(\n          FCMDetails.SUBSCRIPTION_OPTIONS\n        );\n      })\n      .then(sub => {\n        subscription = sub;\n        return this.subscribeToFCM(senderId, subscription);\n      })\n      .then(tokenDetails => {\n        fcmTokenDetails = tokenDetails;\n        return this.saveTokenDetails_(\n          senderId,\n          swRegistration,\n          subscription,\n          fcmTokenDetails['token'],\n          fcmTokenDetails['pushSet']\n        );\n      })\n      .then(() => fcmTokenDetails['token']);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  deleteToken(token) {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN)\n      );\n    }\n\n    return this.getTokenDetailsFromToken(token).then(details => {\n      if (!details) {\n        throw this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return this.openDatabase_().then(db => {\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction(\n            [FCM_TOKEN_OBJ_STORE],\n            'readwrite'\n          );\n          const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          const request = objectStore.delete(details['swScope']);\n          request.onerror = event => {\n            reject((<IDBRequest>event.target).error);\n          };\n          request.onsuccess = event => {\n            if ((<IDBRequest>event.target).result === 0) {\n              reject(\n                this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN)\n              );\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}